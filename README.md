# Introduction:
This is an implementation of the UART module using Verilog HDL, which enables the establishment of transmitter and receiver on the FPGA board. Both the transmitter and receivers can function at the same time and run at the baud rate. The baud rate can explicitely be set to a factor of the basic clock frequency and an additional factor of (divide by) 16 is included as the reciever needs a faster clock (16 times faster) to sample the values being recieved in a single clock cycle (of the clock running at baud rate). This eradicates the chances of glitches causing the wrong value to be sampled and received. The transmission and reception are not triggered by default. Instead, they can be controlled explicitely by the ideal and ideal_rx signals. ![Block diagram of the UART SoC](https://github.com/shrutiprakashgupta/UART-SoC/blob/main/simultation_output/UART.JPG) ![Clock Generation](https://github.com/shrutiprakashgupta/UART-SoC/blob/main/simultation_output/Timing.JPG)
# Usage:
Any design implementation on the FPGA board needs to communicate with other devices. When off-chip communication is used, several external ports and connections need to be made in addition to the FPGA board. This simple module can be mapped on the board along side the actual design enabling a simpler method of communication, saving the need of external connections.  
# Components:
The main components are the Interface module (which manages the input and output signals to the UART module and synchronizes them), the Baud rate generator (which genertes the clock at baud rate by dividing the original clk, and further converting into a divide by 16 clock) and the reciever and transmitter modules.
# Transmitter module:
It functions at the baud rate and generates the signal to be transmitted at every negative edge of the clock (with baud rate frequency). This beginnig of any transmission cycle is controlled by the Ideal signal and then a High to low transition in the Tx signal. The signals can be sampled at the receiver at the negative edge (by using baud rate clock, starting from the high to low transition) of the clock. Apart from this, the data to be transferred is stored in the data register and then transmitted in a synchronized fashion. ![Transmitter Simulation Output](https://github.com/shrutiprakashgupta/UART-SoC/blob/main/simultation_output/Transmit.JPG)
# Receiver module:
The receiver samples the received signal 16 times in one clock cycle and then uses the majority of readings to decide the final value. This removes the chances of errors occuring due to short glitches. It thus samples the received signal at baud rate and stores them in the Receive Hold Register. As soon as it gets filled, the data is stored in the recv_data registers. ![Receiver Simulation Output](https://github.com/shrutiprakashgupta/UART-SoC/blob/main/simultation_output/Receiver.JPG) 
# Interrupt control: 
A parity bit is assigned to every 8 bit data transferred. The settings of the parity bit and the very usage of it can be changed using the LCR (line control register value). There is a provision for the receiver to generate an interrupt in case a wrong value is transmitted (which does not satisfy the parity condition). This interrupt causes the previous sample of the data to be resent. ![Receiver Simulation Output](https://github.com/shrutiprakashgupta/UART-SoC/blob/main/simultation_output/interrup.JPG) 
# Conclusion:
This module has implemented a simple model of the UART module, however, it does not use the FIFO buffer. This means that only one sample of the data can be used for transmission and reception at a time and both transmitter and receiver must work at the same baud rate. Moreover, the LCR, DLL and DLH register values are set internally, these can be changed into board input for more flexibility. It would require 8*3 = 24 input pins, thus this provision is not provided (it would depend on the board). 
